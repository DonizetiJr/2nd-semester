#include <stdlib.h>
#include <stdio.h>
#include <listaligada.h>

/* Cria um nó que será colocado na lista. */
NO *criar_no(ITEM *item, NO *proximo, NO *anterior) {
  NO *novo = (NO *)malloc(sizeof(NO));

  /* Atribui os dados necessários para o estabelecimento do nó. */
  if(novo != NULL) {
    novo->item = item;
    novo->proximo = proximo;
    novo->anterior = anterior;

    return novo;
  }
  
  return NULL;
}

/* Libera a memória ocupada pelo nó. */
void apagar_no(NO *no) {
  apagar_item(&(no->item));
  free(no);
}

/* Aloca o nó representado pelo sentinela, atribuindo valores inválidos. */
void criar_sentinela(LISTA_LIGADA *lista) {
  if(lista != NULL) {
    char cpf[] = {-1};
    char primeiro_nome[] = {-1};
    char ultimo_nome[] = {-1};
    char telefone[] = {-1};
    
    lista->sentinela = criar_no(criar_item(cpf, primeiro_nome, ultimo_nome, telefone), NULL, NULL);

    /* Por ser lista circular, os nós anterior e posterior serão o próprio sentinela. */
    lista->sentinela->proximo = lista->sentinela;
    lista->sentinela->anterior = lista->sentinela;
  }
}

/* Cria uma lista duplamente ligada, circular, com sentinela incialmente vazia. */
LISTA_LIGADA *criar_lista() {
  LISTA_LIGADA *lista = (LISTA_LIGADA *)malloc(sizeof(LISTA_LIGADA));

  if(lista != NULL){
    criar_sentinela(lista);
    lista->fim = NULL;
    lista->tamanho = 0;
  }
  
  return lista;
}

/* Verifica se a lista está cheia, ie, não há mais memória disponível para alocar. */
int cheia(LISTA_LIGADA *lista) {
  return (lista == NULL);
}

/* Verifica se a lista está vazia. */
int vazia(LISTA_LIGADA *lista){
  return (lista->sentinela->proximo == lista->sentinela);
}

/* Retorna o número de nós presentes na lista. */
int tamanho(LISTA_LIGADA *lista){
  if(lista != NULL) {
    return (lista->tamanho);
  }
  return 0;
}
/* Libera toda a memória possivelmente alocada pelo sistema. */
void sair_gerenciamento(LISTA_LIGADA **lista) {
  if (lista != NULL && *lista != NULL) {
    if(!vazia(*lista)) {
      NO *prem = (*lista)->sentinela->proximo;
      NO *paux = prem;

      while (paux != (*lista)->sentinela) {
	prem = paux;
	paux = paux->proximo;
	apagar_no(prem);
      }
    }
    free(*lista);
    *lista = NULL;
  }
}

/* Cria um novo usuário com todas as informações fornecidas. */
void cadastro(LISTA_LIGADA *lista, char cpf[], char primeiro_nome[],
	      char ultimo_nome[], char telefone[]) {
  if(lista != NULL) {
    ITEM *item = criar_item(cpf, primeiro_nome, ultimo_nome, telefone);

    if (lista != NULL) {
      NO *pnovo = (NO *)malloc(sizeof(NO));

      if (pnovo != NULL) {
	pnovo->item = item;
	pnovo->proximo = lista->sentinela;

	if (lista->sentinela->proximo == lista->sentinela) {
	  /* Caso a lista esteja vazia. */
	  lista->sentinela->proximo = pnovo;
	  pnovo->anterior = lista->sentinela;
	} else {
	  /* Os novos usuários sempre serão armazenados no final da lista */
          pnovo->anterior = lista->fim;
          lista->fim->proximo = pnovo;
	}

	lista->fim = pnovo;
	lista->tamanho++;
      }
    }
  }
}

/* Busca o usuário na lista de acordo com o CPF e ao encontrar imprime seus dados. */
void buscar_cpf(LISTA_LIGADA *lista, char cpf[]){
  if (lista != NULL) {
    strcpy(lista->sentinela->item->cpf,cpf);
    NO *paux = lista->sentinela->proximo;
    
    while (strcmp(paux->item->cpf, cpf)){
      paux = paux->proximo;
    }

    /* Caso o nó encontrado não seja o prório sentinela */
    if(paux != lista->sentinela) {
      imprimir_item(paux->item);
    }
  }
}

/* Imprime na tela os dados de todos os usuários na ordem com que foram inseridos. */
void dump(LISTA_LIGADA *lista){
  if(lista != NULL && !vazia(lista)) {
    NO *paux = lista->sentinela->proximo;

    while (paux != lista->sentinela) {
      imprimir_item(paux->item);
      paux = paux->proximo;
    }
  }
}

/* Invalida os dados do usuário de acordo com o CPF, ie, libera a memória ocupada por ele. */
void remover_cpf(LISTA_LIGADA *lista, char cpf[]){
  if(lista != NULL) {
    strcpy(lista->sentinela->item->cpf,cpf);
    NO *prem = lista->sentinela->proximo;

    while (strcmp(prem->item->cpf, cpf)){
      prem = prem->proximo;
    }

    if (prem != lista->sentinela) {
      if (prem == lista->fim) {
	/* Caso o usuário seja o último da lista. */
	prem->anterior->proximo = lista->sentinela;
	lista->fim = prem->anterior;
      } else {
	prem->anterior->proximo = prem->proximo;
	prem->proximo->anterior = prem->anterior;
      }
    }
    
    lista->tamanho--;
    apagar_no(prem);
  }
}
